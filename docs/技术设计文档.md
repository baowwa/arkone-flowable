---                                                                                                                                                                                                      
ArkOne 测序流程配置系统 - 技术设计文档

文档版本: v1.0
编制日期: 2026-02-24
架构师: 技术架构团队

  ---
一、系统架构设计

1.1 总体架构

┌─────────────────────────────────────────────────────────┐
│                    前端层 (Vue 3)                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │流程配置UI│  │样本管理UI│  │数据统计UI│              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────────────────────────────────────────┘
↓ HTTPS/REST API
┌─────────────────────────────────────────────────────────┐
│                  API网关层 (Nginx)                       │
│  ┌─────────────────────────────────────────────┐        │
│  │ 路由、负载均衡、限流、认证                    │        │
│  └─────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│              应用服务层 (Spring Boot)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │流程管理服务  │  │样本管理服务  │  │数据管理服务  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │权限管理服务  │  │通知服务      │  │报表服务      │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│              工作流引擎层 (Flowable)                     │
│  ┌─────────────────────────────────────────────┐        │
│  │ 流程定义、流程实例、任务管理、事件监听       │        │
│  └─────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│              数据访问层 (MyBatis-Plus)                   │
│  ┌─────────────────────────────────────────────┐        │
│  │ DAO、Mapper、实体映射                        │        │
│  └─────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────┐
│                  数据存储层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ PostgreSQL   │  │ Redis        │  │ MinIO        │  │
│  │ (主数据库)   │  │ (缓存)       │  │ (文件存储)   │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘

1.2 技术栈选型

后端:
- Spring Boot 3.5.x - 应用框架
- Flowable 7.0.x - 工作流引擎
- MyBatis-Plus 3.5.x - ORM框架
- PostgreSQL 17+ - 关系型数据库
- Redis 7.x - 缓存和会话存储
- RabbitMQ 3.12.x - 消息队列
- MinIO - 对象存储

前端:
- Vue 3.4.x + TypeScript 5.x
- Element Plus 2.5.x - UI组件库
- bpmn-js 17.x - BPMN流程建模
- ECharts 5.x - 数据可视化
- Pinia - 状态管理
- Vue Router 4.x - 路由管理
- Axios - HTTP客户端

开发工具:
- Maven 3.9.x - 构建工具
- Vite 5.x - 前端构建工具
- Docker - 容器化
- Git - 版本控制

  ---
二、数据库设计

2.1 核心表结构

2.1.1 样本表 (lims_sample)

CREATE TABLE lims_sample (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
sample_code VARCHAR(50) UNIQUE NOT NULL,
sample_name VARCHAR(200),
project_id UUID NOT NULL,
sample_type VARCHAR(50) NOT NULL,
status VARCHAR(20) DEFAULT 'pending',
current_node VARCHAR(100),
container_id UUID,
position VARCHAR(20),
parent_sample_id UUID,
created_by VARCHAR(100),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_by VARCHAR(100),
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
deleted BOOLEAN DEFAULT FALSE,

      CONSTRAINT fk_project FOREIGN KEY (project_id) REFERENCES lims_project(id),
      CONSTRAINT fk_container FOREIGN KEY (container_id) REFERENCES lims_container(id),
      CONSTRAINT fk_parent_sample FOREIGN KEY (parent_sample_id) REFERENCES lims_sample(id)
);

CREATE INDEX idx_sample_code ON lims_sample(sample_code);
CREATE INDEX idx_sample_type ON lims_sample(sample_type);
CREATE INDEX idx_sample_status ON lims_sample(status);
CREATE INDEX idx_sample_project ON lims_sample(project_id);
CREATE INDEX idx_sample_created_at ON lims_sample(created_at DESC);

2.1.2 检验项目表 (lims_project)

CREATE TABLE lims_project (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
project_code VARCHAR(50) UNIQUE NOT NULL,
project_name VARCHAR(200) NOT NULL,
description TEXT,
process_definition_id VARCHAR(64),
status VARCHAR(20) DEFAULT 'active',
created_by VARCHAR(100),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_project_code ON lims_project(project_code);
CREATE INDEX idx_project_status ON lims_project(status);

2.1.3 流程节点数据表 (lims_process_node_data)

CREATE TABLE lims_process_node_data (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
sample_id UUID NOT NULL,
node_id VARCHAR(100) NOT NULL,
node_name VARCHAR(200) NOT NULL,
data JSONB NOT NULL,
status VARCHAR(20) DEFAULT 'completed',
created_by VARCHAR(100),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

      CONSTRAINT fk_sample FOREIGN KEY (sample_id) REFERENCES lims_sample(id) ON DELETE CASCADE
);

CREATE INDEX idx_node_data_sample ON lims_process_node_data(sample_id);
CREATE INDEX idx_node_data_node ON lims_process_node_data(node_id);
CREATE INDEX idx_node_data_gin ON lims_process_node_data USING GIN (data);
CREATE INDEX idx_node_data_created_at ON lims_process_node_data(created_at DESC);

2.1.4 字段定义表 (lims_field_definition)

CREATE TABLE lims_field_definition (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
node_id VARCHAR(100) NOT NULL,
field_name VARCHAR(100) NOT NULL,
field_label VARCHAR(200),
field_type VARCHAR(50) NOT NULL,
unit VARCHAR(50),
required BOOLEAN DEFAULT FALSE,
default_value VARCHAR(500),
validation_rule JSONB,
formula VARCHAR(500),
options JSONB,
display_order INT DEFAULT 0,
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

      CONSTRAINT uk_node_field UNIQUE (node_id, field_name)
);

CREATE INDEX idx_field_node ON lims_field_definition(node_id);

2.1.5 容器表 (lims_container)

CREATE TABLE lims_container (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
container_code VARCHAR(50) UNIQUE NOT NULL,
container_type VARCHAR(50) NOT NULL,
capacity INT NOT NULL,
used_count INT DEFAULT 0,
status VARCHAR(20) DEFAULT 'active',
created_by VARCHAR(100),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_container_code ON lims_container(container_code);
CREATE INDEX idx_container_type ON lims_container(container_type);

2.1.6 审计日志表 (lims_audit_log)

CREATE TABLE lims_audit_log (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
user_id VARCHAR(100),
user_name VARCHAR(200),
action VARCHAR(100) NOT NULL,
entity_type VARCHAR(100),
entity_id UUID,
old_value JSONB,
new_value JSONB,
ip_address VARCHAR(50),
user_agent VARCHAR(500),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_audit_user ON lims_audit_log(user_id);
CREATE INDEX idx_audit_entity ON lims_audit_log(entity_type, entity_id);
CREATE INDEX idx_audit_created_at ON lims_audit_log(created_at DESC);
CREATE INDEX idx_audit_old_value_gin ON lims_audit_log USING GIN (old_value);
CREATE INDEX idx_audit_new_value_gin ON lims_audit_log USING GIN (new_value);

2.2 JSONB字段设计

process_node_data.data 字段结构:
{
"48深孔板号": "P001",
"48深孔板孔号": "A01",
"摇菌开始时间": "2026-02-24T09:45:00",
"摇菌截止时间": "2026-02-24T10:30:00",
"核酸浓度": 125.5,
"补ddH₂O": 10.2
}

field_definition.validation_rule 字段结构:
{
"type": "number",
"min": 0,
"max": 1000,
"pattern": null,
"message": "请输入0-1000之间的数值"
}

field_definition.options 字段结构:
{
"items": [
{"label": "平板样本", "value": "plate"},
{"label": "直抽菌液", "value": "liquid"},
{"label": "质粒核酸", "value": "plasmid"}
]
}

2.3 索引优化策略

GIN索引用于JSONB查询:
-- 支持 data->>'字段名' 查询
CREATE INDEX idx_node_data_gin ON lims_process_node_data USING GIN (data);

-- 支持特定字段的B-tree索引（高频查询字段）
CREATE INDEX idx_node_data_barcode ON lims_process_node_data ((data->>'barcode'));
CREATE INDEX idx_node_data_concentration ON lims_process_node_data ((data->>'核酸浓度'));

  ---
三、Flowable集成方案

3.1 流程定义

BPMN流程定义示例:
  <?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
targetNamespace="http://arkone.com/lims">

    <process id="plasmid_sequencing" name="全质粒测序流程">

      <!-- 开始节点 -->
      <startEvent id="start" name="开始"/>

      <!-- 样本登记 -->
      <userTask id="sample_register" name="样本登记"/>

      <!-- 样本类型判断网关 -->
      <exclusiveGateway id="gateway_sample_type" name="样本类型判断"/>

      <!-- 平板样本分支 -->
      <sequenceFlow sourceRef="gateway_sample_type" targetRef="task_shake">
        <conditionExpression>${sampleType == 'plate'}</conditionExpression>
      </sequenceFlow>
      <userTask id="task_shake" name="摇菌"/>

      <!-- 直抽菌液分支 -->
      <sequenceFlow sourceRef="gateway_sample_type" targetRef="task_extract">
        <conditionExpression>${sampleType == 'liquid'}</conditionExpression>
      </sequenceFlow>

      <!-- 质粒核酸分支 -->
      <sequenceFlow sourceRef="gateway_sample_type" targetRef="task_preprocess">
        <conditionExpression>${sampleType == 'plasmid'}</conditionExpression>
      </sequenceFlow>

      <!-- 后续节点... -->
      <userTask id="task_extract" name="核酸提取"/>
      <userTask id="task_preprocess" name="样本前处理"/>
      <userTask id="task_library" name="文库构建"/>
      <userTask id="task_sequencing" name="上机测序"/>

      <endEvent id="end" name="结束"/>
    </process>

  </definitions>

3.2 流程变量管理

流程变量定义:
// 启动流程时设置变量
Map<String, Object> variables = new HashMap<>();
variables.put("sampleId", sample.getId());
variables.put("sampleType", sample.getSampleType());
variables.put("projectId", sample.getProjectId());

ProcessInstance processInstance = runtimeService
.startProcessInstanceByKey("plasmid_sequencing", variables);

节点数据存储:
// 完成任务时保存节点数据
@Transactional
public void completeTask(String taskId, Map<String, Object> nodeData) {
// 1. 保存节点数据到 lims_process_node_data
ProcessNodeData data = new ProcessNodeData();
data.setSampleId(sampleId);
data.setNodeId(taskId);
data.setNodeName(taskName);
data.setData(nodeData); // JSONB
processNodeDataMapper.insert(data);

      // 2. 完成Flowable任务
      taskService.complete(taskId, nodeData);
}

3.3 条件分支实现

排他网关配置:
@Service
public class SampleTypeRouter {

      public String determinePath(String sampleType) {
          switch (sampleType) {
              case "plate":
              case "bacteria":
                  return "shake_path"; // 需要摇菌
              case "liquid":
                  return "extract_path"; // 直接提取
              case "plasmid":
                  return "preprocess_path"; // 直接前处理
              default:
                  throw new BusinessException("未知样本类型");
          }
      }
}

  ---
四、核心模块设计

4.1 流程管理模块

类结构:
// 流程定义服务
@Service
public class ProcessDefinitionService {

      // 部署流程
      public String deployProcess(String bpmnXml) {
          Deployment deployment = repositoryService
              .createDeployment()
              .addString("process.bpmn20.xml", bpmnXml)
              .deploy();
          return deployment.getId();
      }

      // 启动流程实例
      public ProcessInstance startProcess(String sampleId, String processKey) {
          Sample sample = sampleService.getById(sampleId);
          Map<String, Object> variables = buildProcessVariables(sample);
          return runtimeService.startProcessInstanceByKey(processKey, variables);
      }

      // 查询流程实例
      public ProcessInstance getProcessInstance(String sampleId) {
          return runtimeService.createProcessInstanceQuery()
              .variableValueEquals("sampleId", sampleId)
              .singleResult();
      }
}

4.2 样本管理模块

类结构:
// 样本服务
@Service
public class SampleService {

      @Autowired
      private SampleMapper sampleMapper;

      @Autowired
      private ProcessDefinitionService processService;

      // 创建样本并启动流程
      @Transactional
      public Sample createSample(SampleCreateDTO dto) {
          // 1. 生成样本编号
          String sampleCode = generateSampleCode();

          // 2. 创建样本记录
          Sample sample = new Sample();
          sample.setSampleCode(sampleCode);
          sample.setSampleName(dto.getSampleName());
          sample.setProjectId(dto.getProjectId());
          sample.setSampleType(dto.getSampleType());
          sample.setStatus("pending");
          sampleMapper.insert(sample);

          // 3. 启动流程实例
          String processKey = getProcessKeyByProject(dto.getProjectId());
          processService.startProcess(sample.getId(), processKey);

          // 4. 更新样本状态
          sample.setStatus("in_progress");
          sampleMapper.updateById(sample);

          return sample;
      }

      // 生成样本编号
      private String generateSampleCode() {
          String date = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
          Long sequence = redisTemplate.opsForValue().increment("sample:sequence:" + date);
          return String.format("AK%s%03d", date, sequence);
      }
}

4.3 动态表单引擎

字段配置加载:
@Service
public class DynamicFormService {

      // 获取节点字段配置
      public List<FieldDefinition> getNodeFields(String nodeId) {
          return fieldDefinitionMapper.selectList(
              new LambdaQueryWrapper<FieldDefinition>()
                  .eq(FieldDefinition::getNodeId, nodeId)
                  .orderByAsc(FieldDefinition::getDisplayOrder)
          );
      }

      // 验证节点数据
      public ValidationResult validateNodeData(String nodeId, Map<String, Object> data) {
          List<FieldDefinition> fields = getNodeFields(nodeId);
          ValidationResult result = new ValidationResult();

          for (FieldDefinition field : fields) {
              Object value = data.get(field.getFieldName());

              // 必填验证
              if (field.getRequired() && (value == null || value.toString().isEmpty())) {
                  result.addError(field.getFieldName(), "该字段为必填项");
                  continue;
              }

              // 类型验证
              if (value != null) {
                  validateFieldType(field, value, result);
                  validateFieldRule(field, value, result);
              }
          }

          return result;
      }

      // 计算字段
      public Map<String, Object> calculateFields(String nodeId, Map<String, Object> data) {
          List<FieldDefinition> calculatedFields = getCalculatedFields(nodeId);
          Map<String, Object> result = new HashMap<>(data);

          for (FieldDefinition field : calculatedFields) {
              Object calculatedValue = evaluateFormula(field.getFormula(), data);
              result.put(field.getFieldName(), calculatedValue);
          }

          return result;
      }
}

4.4 容器管理模块

类结构:
@Service
public class ContainerService {

      // 创建容器
      public Container createContainer(String containerType) {
          Container container = new Container();
          container.setContainerCode(generateContainerCode(containerType));
          container.setContainerType(containerType);
          container.setCapacity(getCapacityByType(containerType));
          container.setUsedCount(0);
          containerMapper.insert(container);
          return container;
      }

      // 分配孔位
      @Transactional
      public void assignPosition(UUID sampleId, UUID containerId, String position) {
          // 1. 检查孔位是否可用
          Sample existingSample = sampleMapper.selectOne(
              new LambdaQueryWrapper<Sample>()
                  .eq(Sample::getContainerId, containerId)
                  .eq(Sample::getPosition, position)
                  .eq(Sample::getDeleted, false)
          );

          if (existingSample != null) {
              throw new BusinessException("孔位已被占用");
          }

          // 2. 更新样本位置
          Sample sample = sampleMapper.selectById(sampleId);
          sample.setContainerId(containerId);
          sample.setPosition(position);
          sampleMapper.updateById(sample);

          // 3. 更新容器使用数
          Container container = containerMapper.selectById(containerId);
          container.setUsedCount(container.getUsedCount() + 1);
          containerMapper.updateById(container);
      }

      // 获取板位图
      public PlateMapVO getPlateMap(UUID containerId) {
          Container container = containerMapper.selectById(containerId);
          List<Sample> samples = sampleMapper.selectList(
              new LambdaQueryWrapper<Sample>()
                  .eq(Sample::getContainerId, containerId)
                  .eq(Sample::getDeleted, false)
          );

          return buildPlateMap(container, samples);
      }
}

  ---
五、API接口设计

5.1 RESTful API规范

基础URL: http://api.arkone.com/v1

通用响应格式:
{
"code": 200,
"message": "success",
"data": {},
"timestamp": "2026-02-24T16:30:00"
}

5.2 样本管理API

创建样本

POST /samples
Content-Type: application/json

Request:
{
"sampleName": "Sample-01",
"projectId": "uuid",
"sampleType": "plate",
"submitter": "张三",
"remark": "备注信息"
}

Response:
{
"code": 200,
"data": {
"id": "uuid",
"sampleCode": "AK20260224001",
"sampleName": "Sample-01",
"status": "in_progress",
"processInstanceId": "12345"
}
}

查询样本列表

GET /samples?page=1&size=10&projectId=uuid&status=in_progress&keyword=Sample

Response:
{
"code": 200,
"data": {
"total": 156,
"records": [
{
"id": "uuid",
"sampleCode": "AK20260224001",
"sampleName": "Sample-01",
"projectName": "全质粒测序",
"sampleType": "平板样本",
"currentNode": "核酸提取",
"status": "in_progress",
"createdAt": "2026-02-24T09:30:00"
}
]
}
}

获取样本详情

GET /samples/{sampleId}

Response:
{
"code": 200,
"data": {
"id": "uuid",
"sampleCode": "AK20260224001",
"sampleName": "Sample-01",
"projectName": "全质粒测序",
"sampleType": "平板样本",
"status": "in_progress",
"currentNode": "样本前处理",
"processProgress": [
{"node": "摇菌", "status": "completed", "completedAt": "2026-02-24T10:30:00"},
{"node": "核酸提取", "status": "completed", "completedAt": "2026-02-24T12:00:00"},
{"node": "样本前处理", "status": "in_progress", "startedAt": "2026-02-24T14:20:00"}
],
"nodeDataList": [
{
"nodeId": "task_shake",
"nodeName": "摇菌",
"data": {
"48深孔板号": "P001",
"48深孔板孔号": "A01"
},
"createdBy": "王五",
"createdAt": "2026-02-24T10:30:00"
}
]
}
}

5.3 流程管理API

获取节点字段配置

GET /process/nodes/{nodeId}/fields

Response:
{
"code": 200,
"data": [
{
"fieldName": "核酸浓度",
"fieldLabel": "核酸浓度",
"fieldType": "number",
"unit": "ng/μL",
"required": true,
"validationRule": {
"min": 0,
"max": 1000
}
},
{
"fieldName": "补ddH₂O",
"fieldType": "number",
"unit": "μL",
"required": false,
"formula": "(目标浓度 - 核酸浓度) * 体积"
}
]
}

提交节点数据

POST /process/tasks/{taskId}/complete
Content-Type: application/json

Request:
{
"data": {
"核酸浓度": 125.5,
"补ddH₂O": 10.2
},
"remark": "数据正常"
}

Response:
{
"code": 200,
"data": {
"taskId": "12345",
"nextNode": "文库构建",
"status": "completed"
}
}

5.4 容器管理API

获取板位图

GET /containers/{containerId}/plate-map

Response:
{
"code": 200,
"data": {
"containerId": "uuid",
"containerCode": "P096-001",
"containerType": "96孔板",
"capacity": 96,
"usedCount": 45,
"positions": [
{
"position": "A01",
"status": "used",
"sampleId": "uuid",
"sampleCode": "AK20260224001"
},
{
"position": "A02",
"status": "used",
"sampleId": "uuid2",
"sampleCode": "AK20260224002"
},
{
"position": "A03",
"status": "empty"
}
]
}
}

5.5 流程定义管理API

查询流程定义列表

GET /process/definitions?page=1&size=10&keyword=测序

Response:
{
"code": 200,
"data": {
"total": 5,
"records": [
{
"id": "plasmid_sequencing:3:12345",
"key": "plasmid_sequencing",
"name": "全质粒测序流程",
"version": 3,
"deploymentTime": "2026-02-24T10:00:00",
"status": "active"
}
]
}
}

部署流程定义

POST /process/definitions
Content-Type: multipart/form-data

Request:
- file: BPMN XML文件
- name: 流程名称
- description: 流程描述

Response:
{
"code": 200,
"data": {
"id": "plasmid_sequencing:4:67890",
"key": "plasmid_sequencing",
"version": 4,
"deploymentId": "deployment-uuid"
}
}

获取流程定义XML

GET /process/definitions/{definitionId}/xml

Response:
{
"code": 200,
"data": {
"bpmnXml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>..."
}
}

挂起/激活流程实例

POST /process/instances/{instanceId}/suspend

Request:
{
"reason": "暂停原因"
}

Response:
{
"code": 200,
"data": {
"instanceId": "12345",
"status": "suspended"
}
}

POST /process/instances/{instanceId}/activate

Response:
{
"code": 200,
"data": {
"instanceId": "12345",
"status": "active"
}
}

5.6 任务管理API

查询我的待办任务

GET /process/tasks/my?page=1&size=10&processKey=plasmid_sequencing

Response:
{
"code": 200,
"data": {
"total": 23,
"records": [
{
"taskId": "task-12345",
"taskName": "核酸提取",
"processInstanceId": "instance-67890",
"sampleCode": "AK20260224001",
"sampleName": "Sample-01",
"createdTime": "2026-02-24T09:30:00",
"assignee": null
}
]
}
}

认领任务

POST /process/tasks/{taskId}/claim

Response:
{
"code": 200,
"data": {
"taskId": "task-12345",
"assignee": "user-001"
}
}

委派任务

POST /process/tasks/{taskId}/delegate

Request:
{
"targetUserId": "user-002",
"reason": "委派原因"
}

Response:
{
"code": 200,
"data": {
"taskId": "task-12345",
"assignee": "user-002"
}
}

5.7 批量操作API

批量创建样本

POST /samples/batch
Content-Type: application/json

Request:
{
"atomic": false,
"samples": [
{
"sampleName": "Sample-01",
"projectId": "uuid",
"sampleType": "plate"
},
{
"sampleName": "Sample-02",
"projectId": "uuid",
"sampleType": "plate"
}
]
}

Response:
{
"code": 200,
"data": {
"successCount": 1,
"failureCount": 1,
"results": [
{
"index": 0,
"success": true,
"sampleId": "uuid-001",
"sampleCode": "AK20260224001"
},
{
"index": 1,
"success": false,
"errorCode": "DUPLICATE_SAMPLE_NAME",
"errorMessage": "样本名称已存在"
}
]
}
}

批量更新样本状态

PUT /samples/batch/status
Content-Type: application/json

Request:
{
"atomic": true,
"sampleIds": ["uuid-001", "uuid-002"],
"status": "cancelled",
"reason": "批量取消原因"
}

Response:
{
"code": 200,
"data": {
"successCount": 2,
"failureCount": 0
}
}

批量完成任务

POST /process/tasks/batch/complete
Content-Type: application/json

Request:
{
"atomic": false,
"tasks": [
{
"taskId": "task-001",
"data": {"核酸浓度": 125.5}
},
{
"taskId": "task-002",
"data": {"核酸浓度": 130.2}
}
]
}

Response:
{
"code": 200,
"data": {
"successCount": 1,
"failureCount": 1,
"results": [
{
"taskId": "task-001",
"success": true
},
{
"taskId": "task-002",
"success": false,
"errorCode": "VALIDATION_FAILED",
"errorMessage": "核酸浓度超出范围"
}
]
}
}

5.8 统计报表API

样本状态统计

GET /statistics/samples/status?projectId=uuid&startDate=2026-02-01&endDate=2026-02-28

Response:
{
"code": 200,
"data": {
"total": 500,
"statusDistribution": {
"pending": 50,
"in_progress": 200,
"completed": 230,
"exception": 15,
"cancelled": 5
}
}
}

流程性能统计

GET /statistics/process/performance?processKey=plasmid_sequencing&startDate=2026-02-01&endDate=2026-02-28

Response:
{
"code": 200,
"data": {
"totalInstances": 230,
"completedInstances": 200,
"avgDuration": 172800000,
"avgDurationHours": 48,
"completionRate": 0.87
}
}

节点耗时统计

GET /statistics/nodes/duration?processKey=plasmid_sequencing&startDate=2026-02-01&endDate=2026-02-28

Response:
{
"code": 200,
"data": [
{
"nodeId": "task_shake",
"nodeName": "摇菌",
"avgDuration": 28800000,
"avgDurationHours": 8,
"minDuration": 21600000,
"maxDuration": 36000000
},
{
"nodeId": "task_extraction",
"nodeName": "核酸提取",
"avgDuration": 14400000,
"avgDurationHours": 4
}
]
}
}

5.9 统一错误码定义

| 错误码 | HTTP状态码 | 说明 |
|--------|-----------|------|
| 200 | 200 | 成功 |
| 400 | 400 | 请求参数错误 |
| 401 | 401 | 未认证 |
| 403 | 403 | 无权限 |
| 404 | 404 | 资源不存在 |
| 409 | 409 | 资源冲突 |
| 500 | 500 | 服务器内部错误 |
| SAMPLE_NOT_FOUND | 404 | 样本不存在 |
| DUPLICATE_SAMPLE_NAME | 409 | 样本名称重复 |
| INVALID_SAMPLE_STATUS | 400 | 样本状态不合法 |
| TASK_NOT_FOUND | 404 | 任务不存在 |
| TASK_ALREADY_COMPLETED | 409 | 任务已完成 |
| VALIDATION_FAILED | 400 | 数据验证失败 |
| POSITION_OCCUPIED | 409 | 孔位已被占用 |
| CONTAINER_NOT_FOUND | 404 | 容器不存在 |
| FORMULA_CALCULATION_ERROR | 500 | 公式计算错误 |
| PROCESS_INSTANCE_NOT_FOUND | 404 | 流程实例不存在 |

错误响应格式:
{
"code": 400,
"message": "数据验证失败",
"errorCode": "VALIDATION_FAILED",
"errors": [
{
"field": "核酸浓度",
"message": "必须在0-1000之间"
}
],
"timestamp": "2026-02-24T16:30:00"
}

  ---
六、关键技术实现

6.1 动态表单引擎

前端实现:
// 动态表单组件
<template>
<el-form :model="formData" :rules="formRules" ref="formRef">
<el-form-item
v-for="field in fields"
:key="field.fieldName"
:label="field.fieldLabel"
:prop="field.fieldName"
:required="field.required"
>
<!-- 文本输入 -->
<el-input
v-if="field.fieldType === 'text'"
v-model="formData[field.fieldName]"
:placeholder="field.placeholder"
/>

        <!-- 数字输入 -->
        <el-input-number
          v-else-if="field.fieldType === 'number'"
          v-model="formData[field.fieldName]"
          :min="field.validationRule?.min"
          :max="field.validationRule?.max"
        />
        <span v-if="field.unit" class="unit">{{ field.unit }}</span>

        <!-- 下拉选择 -->
        <el-select
          v-else-if="field.fieldType === 'select'"
          v-model="formData[field.fieldName]"
        >
          <el-option
            v-for="option in field.options"
            :key="option.value"
            :label="option.label"
            :value="option.value"
          />
        </el-select>

        <!-- 计算字段（只读） -->
        <el-input
          v-else-if="field.fieldType === 'calculated'"
          :value="calculateField(field)"
          readonly
        />
      </el-form-item>
    </el-form>
  </template>

  <script setup lang="ts">
  import { ref, computed, watch } from 'vue'

  const props = defineProps<{
    fields: FieldDefinition[]
  }>()

  const formData = ref<Record<string, any>>({})

  // 计算字段
  const calculateField = (field: FieldDefinition) => {
    if (!field.formula) return ''
    // 使用公式引擎计算
    try {
      const context = { ...formData.value }
      return evaluateFormula(field.formula, context)
    } catch (error) {
      console.error('计算字段失败:', error)
      return ''
    }
  }

  // 监听表单数据变化,触发计算字段更新
  watch(formData, () => {
    // 触发计算字段重新计算
  }, { deep: true })
  </script>
```

**后端公式计算引擎 (Aviator):**

Maven依赖:
```xml
<dependency>
    <groupId>com.googlecode.aviator</groupId>
    <artifactId>aviator</artifactId>
    <version>5.4.1</version>
</dependency>
```

实现代码:
```java
@Service
public class FormulaEngine {

    private static final AviatorEvaluatorInstance evaluator = AviatorEvaluator.newInstance();
    private static final int MAX_FORMULA_LENGTH = 500;
    private static final long EVAL_TIMEOUT_MS = 1000L;

    static {
        // 配置安全选项
        evaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, true);
        evaluator.setOption(Options.TRACE_EVAL, false);
        evaluator.setOption(Options.MAX_LOOP_COUNT, 1000);
        evaluator.setOption(Options.EVAL_TIMEOUT_MS, EVAL_TIMEOUT_MS);

        // 注册白名单函数
        evaluator.addFunction(new MaxFunction());
        evaluator.addFunction(new MinFunction());
        evaluator.addFunction(new RoundFunction());
        evaluator.addFunction(new AbsFunction());
        evaluator.addFunction(new CeilFunction());
        evaluator.addFunction(new FloorFunction());
    }

    /**
     * 计算公式
     * @param formula 公式表达式 (仅支持数值计算和白名单函数)
     * @param context 上下文数据
     * @return 计算结果
     */
    public Object evaluateFormula(String formula, Map<String, Object> context) {
        // 长度限制
        if (formula == null || formula.trim().isEmpty()) {
            throw new BusinessException("公式不能为空");
        }
        if (formula.length() > MAX_FORMULA_LENGTH) {
            throw new BusinessException("公式长度超过限制: " + MAX_FORMULA_LENGTH);
        }

        try {
            // 执行公式计算
            return evaluator.execute(formula, context);
        } catch (ExpressionRuntimeException e) {
            throw new BusinessException("公式计算失败: " + e.getMessage());
        } catch (Exception e) {
            throw new BusinessException("公式执行异常: " + e.getMessage());
        }
    }

    /**
     * 验证公式语法
     */
    public boolean validateFormula(String formula) {
        try {
            evaluator.validate(formula);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}

// 自定义函数示例
class RoundFunction extends AbstractFunction {
    @Override
    public String getName() {
        return "round";
    }

    @Override
    public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {
        Number value = FunctionUtils.getNumberValue(arg1, env);
        Number scale = FunctionUtils.getNumberValue(arg2, env);
        BigDecimal bd = new BigDecimal(value.toString());
        bd = bd.setScale(scale.intValue(), RoundingMode.HALF_UP);
        return AviatorBigDecimal.valueOf(bd);
    }
}
```

支持的公式示例:
```
// 基础运算
末修产物浓度 * 上机文库体积 / 660

// 白名单函数
max(核酸浓度, 10)
round(文库摩尔浓度, 2)
```

### 6.2 条码打印集成

**条码生成服务:**

```java
@Service
public class BarcodeService {
    
    /**
     * 生成条码图片
     * @param content 条码内容
     * @param format 条码格式 (CODE128, QR_CODE等)
     * @return 条码图片Base64
     */
    public String generateBarcode(String content, BarcodeFormat format) {
        try {
            // 使用ZXing生成条码
            BitMatrix bitMatrix = new MultiFormatWriter().encode(
                content,
                format,
                300, // 宽度
                100  // 高度
            );
            
            BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ImageIO.write(image, "PNG", baos);
            
            return Base64.getEncoder().encodeToString(baos.toByteArray());
        } catch (Exception e) {
            throw new BusinessException("条码生成失败", e);
        }
    }
    
    /**
     * 批量打印条码
     * @param sampleIds 样本ID列表
     * @return 打印任务ID
     */
    @Async
    public CompletableFuture<String> batchPrintBarcodes(List<UUID> sampleIds) {
        List<Sample> samples = sampleMapper.selectBatchIds(sampleIds);
        
        // 生成打印数据
        List<BarcodePrintData> printDataList = samples.stream()
            .map(sample -> {
                BarcodePrintData data = new BarcodePrintData();
                data.setBarcode(generateBarcode(sample.getSampleCode(), BarcodeFormat.CODE_128));
                data.setSampleCode(sample.getSampleCode());
                data.setSampleName(sample.getSampleName());
                return data;
            })
            .collect(Collectors.toList());
        
        // 发送到打印队列
        String taskId = UUID.randomUUID().toString();
        rabbitTemplate.convertAndSend("print.queue", printDataList);
        
        return CompletableFuture.completedFuture(taskId);
    }
}
```

### 6.3 Excel导入导出

**Excel导入服务:**

```java
@Service
public class ExcelImportService {
    
    /**
     * 导入样本数据
     * @param file Excel文件
     * @param projectId 项目ID
     * @return 导入结果
     */
    @Transactional
    public ImportResult importSamples(MultipartFile file, UUID projectId) {
        ImportResult result = new ImportResult();
        
        try (InputStream is = file.getInputStream()) {
            Workbook workbook = WorkbookFactory.create(is);
            Sheet sheet = workbook.getSheetAt(0);
            
            // 跳过表头
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) continue;
                
                try {
                    // 解析行数据
                    SampleCreateDTO dto = parseRowToSample(row, projectId);
                    
                    // 验证数据
                    ValidationResult validation = validateSample(dto);
                    if (!validation.isValid()) {
                        result.addError(i, validation.getErrors());
                        continue;
                    }
                    
                    // 创建样本
                    sampleService.createSample(dto);
                    result.incrementSuccess();
                    
                } catch (Exception e) {
                    result.addError(i, e.getMessage());
                }
            }
            
        } catch (Exception e) {
            throw new BusinessException("Excel解析失败", e);
        }
        
        return result;
    }
    
    private SampleCreateDTO parseRowToSample(Row row, UUID projectId) {
        SampleCreateDTO dto = new SampleCreateDTO();
        dto.setProjectId(projectId);
        dto.setSampleName(getCellValue(row, 0));
        dto.setSampleType(getCellValue(row, 1));
        dto.setSubmitter(getCellValue(row, 2));
        dto.setRemark(getCellValue(row, 3));
        return dto;
    }
}
```

**Excel导出服务:**

```java
@Service
public class ExcelExportService {
    
    /**
     * 导出样本数据
     * @param query 查询条件
     * @return Excel文件流
     */
    public ByteArrayOutputStream exportSamples(SampleQuery query) {
        List<Sample> samples = sampleMapper.selectByQuery(query);
        
        try (Workbook workbook = new XSSFWorkbook()) {
            Sheet sheet = workbook.createSheet("样本数据");
            
            // 创建表头
            Row headerRow = sheet.createRow(0);
            String[] headers = {"样本编号", "样本名称", "项目名称", "样本类型", 
                               "当前节点", "状态", "创建时间"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
            }
            
            // 填充数据
            int rowNum = 1;
            for (Sample sample : samples) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(sample.getSampleCode());
                row.createCell(1).setCellValue(sample.getSampleName());
                row.createCell(2).setCellValue(sample.getProjectName());
                row.createCell(3).setCellValue(sample.getSampleType());
                row.createCell(4).setCellValue(sample.getCurrentNode());
                row.createCell(5).setCellValue(sample.getStatus());
                row.createCell(6).setCellValue(sample.getCreatedAt().toString());
            }
            
            // 自动调整列宽
            for (int i = 0; i < headers.length; i++) {
                sheet.autoSizeColumn(i);
            }
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            workbook.write(baos);
            return baos;
            
        } catch (Exception e) {
            throw new BusinessException("Excel导出失败", e);
        }
    }
}
```

### 6.4 审计日志实现

**AOP切面拦截:**

```java
@Aspect
@Component
public class AuditLogAspect {
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Around("@annotation(auditLog)")
    public Object logAudit(ProceedingJoinPoint joinPoint, AuditLog auditLog) throws Throwable {
        // 获取请求信息
        HttpServletRequest request = ((ServletRequestAttributes) 
            RequestContextHolder.getRequestAttributes()).getRequest();
        
        // 获取用户信息
        UserDetails user = SecurityContextHolder.getContext()
            .getAuthentication().getPrincipal();
        
        // 获取方法参数
        Object[] args = joinPoint.getArgs();
        Object oldValue = getOldValue(args);
        
        // 执行方法
        Object result = joinPoint.proceed();
        
        // 记录审计日志
        AuditLogEntity log = new AuditLogEntity();
        log.setUserId(user.getUserId());
        log.setUserName(user.getUsername());
        log.setAction(auditLog.action());
        log.setEntityType(auditLog.entityType());
        log.setEntityId(extractEntityId(args));
        log.setOldValue(toJson(oldValue));
        log.setNewValue(toJson(result));
        log.setIpAddress(request.getRemoteAddr());
        log.setUserAgent(request.getHeader("User-Agent"));
        
        auditLogService.save(log);
        
        return result;
    }
}
```

**使用示例:**

```java
@Service
public class SampleService {
    
    @AuditLog(action = "UPDATE_SAMPLE", entityType = "SAMPLE")
    public Sample updateSample(UUID sampleId, SampleUpdateDTO dto) {
        Sample sample = sampleMapper.selectById(sampleId);
        BeanUtils.copyProperties(dto, sample);
        sampleMapper.updateById(sample);
        return sample;
    }
}
```

---

## 七、性能优化方案

### 7.1 数据库优化

**连接池配置:**

```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
```

**查询优化:**

```java
// 1. 使用索引
@Select("SELECT * FROM lims_sample WHERE sample_code = #{code}")
Sample findBySampleCode(String code);

// 2. 分页查询
Page<Sample> page = new Page<>(pageNum, pageSize);
sampleMapper.selectPage(page, queryWrapper);

// 3. 批量操作
sampleMapper.insertBatch(samples);

// 4. 使用JSONB索引查询
@Select("SELECT * FROM lims_process_node_data WHERE data->>'核酸浓度' > #{minValue}")
List<ProcessNodeData> findByConcentration(Double minValue);
```

### 7.2 缓存策略

**Redis缓存配置:**

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

**缓存使用:**

```java
@Service
public class FieldDefinitionService {
    
    // 缓存字段定义(1小时)
    @Cacheable(value = "field:definition", key = "#nodeId")
    public List<FieldDefinition> getNodeFields(String nodeId) {
        return fieldDefinitionMapper.selectByNodeId(nodeId);
    }
    
    // 更新时清除缓存
    @CacheEvict(value = "field:definition", key = "#nodeId")
    public void updateFieldDefinition(String nodeId, FieldDefinition field) {
        fieldDefinitionMapper.updateById(field);
    }
}
```

### 7.3 异步处理

**异步任务配置:**

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}
```

**异步方法:**

```java
@Service
public class NotificationService {
    
    @Async
    public CompletableFuture<Void> sendEmail(String to, String subject, String content) {
        // 发送邮件逻辑
        emailSender.send(to, subject, content);
        return CompletableFuture.completedFuture(null);
    }
    
    @Async
    public CompletableFuture<Void> sendSms(String phone, String message) {
        // 发送短信逻辑
        smsService.send(phone, message);
        return CompletableFuture.completedFuture(null);
    }
}
```

---

## 八、安全设计

### 8.1 认证授权

**Spring Security配置:**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .addFilterBefore(jwtAuthenticationFilter(), 
                UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

**JWT Token实现:**

```java
@Service
public class JwtTokenService {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userDetails.getUserId());
        claims.put("roles", userDetails.getAuthorities());
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 8.2 数据加密

**敏感字段加密 (AES/GCM):**

```java
@Component
public class FieldEncryptor {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_TAG_LENGTH = 128;
    private static final int GCM_IV_LENGTH = 12;

    @Value("${encryption.key}")
    private String encryptionKey;

    private SecretKey getSecretKey() {
        // 使用SHA-256确保密钥长度为256位
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] keyBytes = digest.digest(encryptionKey.getBytes(StandardCharsets.UTF_8));
            return new SecretKeySpec(keyBytes, "AES");
        } catch (NoSuchAlgorithmException e) {
            throw new BusinessException("密钥生成失败", e);
        }
    }

    public String encrypt(String plainText) {
        try {
            // 生成随机IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            SecureRandom random = new SecureRandom();
            random.nextBytes(iv);

            // 初始化加密器
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), parameterSpec);

            // 加密数据
            byte[] encrypted = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

            // 将IV和密文组合: IV(12字节) + 密文
            byte[] combined = new byte[iv.length + encrypted.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);

            return Base64.getEncoder().encodeToString(combined);
        } catch (Exception e) {
            throw new BusinessException("加密失败", e);
        }
    }

    public String decrypt(String encryptedText) {
        try {
            // 解码Base64
            byte[] combined = Base64.getDecoder().decode(encryptedText);

            // 分离IV和密文
            byte[] iv = new byte[GCM_IV_LENGTH];
            byte[] encrypted = new byte[combined.length - GCM_IV_LENGTH];
            System.arraycopy(combined, 0, iv, 0, iv.length);
            System.arraycopy(combined, iv.length, encrypted, 0, encrypted.length);

            // 初始化解密器
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.DECRYPT_MODE, getSecretKey(), parameterSpec);

            // 解密数据
            byte[] decrypted = cipher.doFinal(encrypted);
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new BusinessException("解密失败", e);
        }
    }
}

// 配置文件 application.yml
// encryption:
//   key: ${ENCRYPTION_KEY:your-secret-key-change-in-production}
//
// 生产环境建议使用密钥管理服务(如AWS KMS、HashiCorp Vault)
```

### 8.3 接口限流

**限流配置:**

```java
@Configuration
public class RateLimitConfig {
    
    @Bean
    public RateLimiter rateLimiter() {
        return RateLimiter.create(100.0); // 每秒100个请求
    }
}

@Aspect
@Component
public class RateLimitAspect {
    
    @Autowired
    private RateLimiter rateLimiter;
    
    @Around("@annotation(rateLimit)")
    public Object limit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        if (!rateLimiter.tryAcquire(rateLimit.timeout(), TimeUnit.MILLISECONDS)) {
            throw new BusinessException("请求过于频繁,请稍后再试");
        }
        return joinPoint.proceed();
    }
}
```

---

## 九、部署方案

### 9.1 Docker容器化

**后端Dockerfile:**

```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY target/arkone-lims.jar app.jar

EXPOSE 8080

ENV JAVA_OPTS="-Xms512m -Xmx2g -XX:+UseG1GC"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

**前端Dockerfile:**

```dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 9.2 Docker Compose编排

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: arkone_lims
      POSTGRES_USER: arkone
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - arkone-network

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - arkone-network

  rabbitmq:
    image: rabbitmq:3.12-management-alpine
    environment:
      RABBITMQ_DEFAULT_USER: arkone
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    networks:
      - arkone-network

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: arkone
      MINIO_ROOT_PASSWORD: ${MINIO_PASSWORD}
    volumes:
      - minio_data:/data
    ports:
      - "9000:9000"
      - "9001:9001"
    networks:
      - arkone-network

  backend:
    build: ./backend
    environment:
      SPRING_PROFILES_ACTIVE: prod
      DB_HOST: postgres
      DB_PORT: 5432
      REDIS_HOST: redis
      REDIS_PORT: 6379
      RABBITMQ_HOST: rabbitmq
      MINIO_ENDPOINT: http://minio:9000
    depends_on:
      - postgres
      - redis
      - rabbitmq
      - minio
    ports:
      - "8080:8080"
    networks:
      - arkone-network

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - arkone-network

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
  minio_data:

networks:
  arkone-network:
    driver: bridge
```

### 9.3 Kubernetes部署

**后端Deployment:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: arkone-backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: arkone-backend
  template:
    metadata:
      labels:
        app: arkone-backend
    spec:
      containers:
      - name: backend
        image: arkone/backend:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: DB_HOST
          valueFrom:
            configMapKeyRef:
              name: arkone-config
              key: db.host
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: arkone-backend-service
spec:
  selector:
    app: arkone-backend
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 8080
  type: LoadBalancer
```

---

## 十、监控运维

### 10.1 应用监控

**Spring Boot Actuator配置:**

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
  health:
    db:
      enabled: true
    redis:
      enabled: true
```

**自定义健康检查:**

```java
@Component
public class FlowableHealthIndicator implements HealthIndicator {
    
    @Autowired
    private RuntimeService runtimeService;
    
    @Override
    public Health health() {
        try {
            long count = runtimeService.createProcessInstanceQuery().count();
            return Health.up()
                .withDetail("processInstanceCount", count)
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

### 10.2 日志管理

**Logback配置:**

```xml
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/arkone-lims.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/arkone-lims.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy 
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
    
    <logger name="com.arkone.lims" level="DEBUG"/>
    <logger name="org.flowable" level="INFO"/>
</configuration>
```

### 10.3 性能监控

**Prometheus + Grafana监控:**

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'arkone-backend'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['backend:8080']
```

**关键指标监控:**

- JVM内存使用率
- GC频率和耗时
- 数据库连接池状态
- API响应时间
- 流程实例数量
- 任务完成率

---

## 十一、测试策略

### 11.1 单元测试

```java
@SpringBootTest
class SampleServiceTest {
    
    @Autowired
    private SampleService sampleService;
    
    @MockBean
    private SampleMapper sampleMapper;
    
    @Test
    void testCreateSample() {
        SampleCreateDTO dto = new SampleCreateDTO();
        dto.setSampleName("Test Sample");
        dto.setProjectId(UUID.randomUUID());
        dto.setSampleType("plate");
        
        Sample sample = sampleService.createSample(dto);
        
        assertNotNull(sample.getId());
        assertNotNull(sample.getSampleCode());
        assertEquals("pending", sample.getStatus());
    }
}
```

### 11.2 集成测试

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class SampleControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void testCreateSampleAPI() throws Exception {
        String requestBody = """
            {
                "sampleName": "Test Sample",
                "projectId": "uuid",
                "sampleType": "plate"
            }
            """;
        
        mockMvc.perform(post("/api/v1/samples")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.sampleCode").exists());
    }
}
```

### 11.3 性能测试

使用JMeter进行压力测试:

- 并发用户数: 100
- 持续时间: 10分钟
- 目标TPS: 500
- 响应时间: P95 < 500ms

---

## 十二、附录

### 12.1 技术选型对比

| 技术类别 | 选型方案 | 备选方案 | 选型理由 |
|---------|---------|---------|---------|
| 工作流引擎 | Flowable | Activiti, Camunda | 功能完善,社区活跃,文档齐全 |
| 数据库 | PostgreSQL | MySQL, Oracle | 支持JSONB,性能优秀,开源免费 |
| 缓存 | Redis | Memcached | 数据结构丰富,支持持久化 |
| 消息队列 | RabbitMQ | Kafka, RocketMQ | 易用性好,适合中小规模 |
| 对象存储 | MinIO | OSS, S3 | 开源,可私有化部署 |

### 12.2 数据字典

详见数据库设计章节的表结构定义。

### 12.3 错误码定义

| 错误码 | 说明 | HTTP状态码 |
|-------|------|-----------|
| 200 | 成功 | 200 |
| 400 | 请求参数错误 | 400 |
| 401 | 未授权 | 401 |
| 403 | 无权限 | 403 |
| 404 | 资源不存在 | 404 |
| 500 | 服务器内部错误 | 500 |
| 1001 | 样本编号已存在 | 400 |
| 1002 | 样本不存在 | 404 |
| 1003 | 流程实例不存在 | 404 |
| 1004 | 节点数据验证失败 | 400 |
| 1005 | 容器孔位已占用 | 400 |

### 12.4 版本历史

| 版本号 | 日期 | 修订内容 | 修订人 |
|-------|------|---------|--------|
| v1.0 | 2026-02-24 | 初始版本 | 技术架构团队 |

---

**文档结束**
